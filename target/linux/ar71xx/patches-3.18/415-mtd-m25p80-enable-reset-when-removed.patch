--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -27,6 +27,11 @@
 #include <linux/spi/flash.h>
 #include <linux/mtd/spi-nor.h>
 
+/* Reset opcodes */
+#define OPCODE_RSTEN		0x66	/* Enable reset */
+#define OPCODE_RESET		0x99	/* Reset device */
+
+
 #define	MAX_CMD_SIZE		6
 struct m25p {
 	struct spi_device	*spi;
@@ -185,6 +190,49 @@
 }
 
 /*
+ * Reset hole flash chip. Only be avaliable for chips size >= 32MiB
+ */
+static inline int flash_reset(struct m25p *flash)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	char command[2];
+	int ret;
+
+	if (flash->addr_width != 4) return 1;
+
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+
+	t[0].tx_buf = &command[0];
+	t[0].len = 1;
+	t[0].cs_change = 1;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = &command[1];
+	t[1].len = 1;
+	t[1].cs_change = 1;
+	spi_message_add_tail(&t[1], &m);
+
+	command[0] = OPCODE_RSTEN;
+	command[1] = OPCODE_RESET;
+
+	mutex_lock(&flash->lock);
+
+	ret = wait_till_ready(flash);
+	if (ret) {
+		mutex_unlock(&flash->lock);
+		return 1;
+	}
+
+	spi_sync(flash->spi, &m);
+
+	mutex_unlock(&flash->lock);
+
+	return 0;
+}
+
+/*
  * board specific setup should have ensured the SPI clock used here
  * matches what the READ command supports, at least until this driver
  * understands FAST_READ (for clocks over 25 MHz).
@@ -258,7 +306,8 @@
 static int m25p_remove(struct spi_device *spi)
 {
 	struct m25p	*flash = spi_get_drvdata(spi);
-
+	/* Reset flash. */
+	flash_reset(flash);
 	/* Clean up MTD stuff. */
 	return mtd_device_unregister(&flash->mtd);
 }
