diff --git a/advkill.c b/advkill.c
index b079dce..015e98a 100644
--- a/advkill.c
+++ b/advkill.c
@@ -10,7 +10,7 @@
 抓取数据包并根据预配置规则进行匹配，若匹配到再根据预配置规则进行
 一系列预定义操作。
 */
-#include <linux/slab.h>
+
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv4.h>
 #include <linux/netfilter_bridge.h>
@@ -28,7 +28,7 @@
 #include <linux/in.h>
 #include <linux/module.h>
 #include <linux/sched.h>   //wake_up_process()
-#include <linux/kthread.h> 
+#include <linux/kthread.h>
 
 #include "advkill.h"
 #include "strcmd.h"
@@ -182,16 +182,28 @@ netfilter注册钩子函数，函数原型为内核确定
 
 在该钩子函数内进行去广告业务处理。
 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 13, 0))
 unsigned int hook_func(	unsigned int hooknum,
 						struct sk_buff **skb,
 						const struct net_device *in,
 						const struct net_device *out,
 						int (*okfn)(struct sk_buff *)
 						)
+#else
+unsigned int hook_func(const struct nf_hook_ops *ops,
+				struct sk_buff *skb,
+				const struct net_device *in,
+				const struct net_device *out,
+				int (*okfn)(struct sk_buff *))
+#endif
 {
 	struct iphdr *iph = NULL;
 	struct tcphdr *tcph = NULL;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 13, 0))
 	struct sk_buff *sb = *skb;
+#else
+	struct sk_buff *sb = skb;
+#endif
 	char *httpcontent = NULL;
 	int httpcontentlen = 0;
 	char *shost = NULL;
@@ -430,8 +442,12 @@ static struct nf_hook_ops nfho_forward =
 {
 	.hook		= hook_func,
 	.owner		= THIS_MODULE,
-	.pf			= PF_INET,
+	.pf		= PF_INET,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (2, 6, 26))
 	.hooknum	= NF_IP_FORWARD,
+#else
+	.hooknum	= NF_INET_FORWARD,
+#endif
 	.priority	= NF_IP_PRI_FIRST,
 };
 
diff --git a/advkill.h b/advkill.h
index 48df8eb..29f4217 100644
--- a/advkill.h
+++ b/advkill.h
@@ -12,10 +12,12 @@
 #ifndef _ADV_KILL_H_
 #define _ADV_KILL_H_
 
+#include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/string.h>
 #include <linux/list.h>
+#include <linux/version.h>
 
 #define _BO_TONG_								1
 
diff --git a/advproc.c b/advproc.c
index db95ec4..4eae57d 100644
--- a/advproc.c
+++ b/advproc.c
@@ -38,8 +38,11 @@ static char *advkillconfdata = NULL; ///< 内核中去广告配置缓冲区地
 @param data 本接口对此没有操作，为内核函数参数格式
 @return 返回读取的长度
 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 10, 0))
 static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, unsigned long len, void *data);
-
+#else
+static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, size_t len, loff_t *data);
+#endif
 /**
 从内核空间将去广告配置内存拷贝到用户空间
 
@@ -51,7 +54,9 @@ static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, u
 @param data 本接口对此没有操作，为内核函数参数格式
 @return 返回写入的长度
 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 10, 0))
 static int advkill_conf_read( char *page, char **start, off_t off, int count, int *eof, void *data);
+#endif
 
 /**
 从用户空间将数据读取到内核空间，解析后保存在哈希表中
@@ -62,7 +67,12 @@ static int advkill_conf_read( char *page, char **start, off_t off, int count, in
 @param data 本接口对此没有操作，为内核函数参数格式
 @return 返回读取的长度
 */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 10, 0))
 static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, unsigned long len, void *data)
+#else
+static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, size_t len, loff_t *data)
+#endif
 {
 	int space_available = (MAX_ADVKILL_CONF_LEN-advkill_conf_index)+1;
 
@@ -72,7 +82,7 @@ static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, u
 		advkill_conf_index = 0;
 		advkill_conf_next = 0;
 	}
-
+	if(advkill_conf_index>0)advkillconfdata[advkill_conf_index-1] = '\n';
 	if (copy_from_user(&advkillconfdata[advkill_conf_index], buff, len )) 
 	{
 		return -EFAULT;
@@ -102,6 +112,7 @@ static ssize_t advkill_conf_write( struct file *filp, const char __user *buff, u
 @param data 本接口对此没有操作，为内核函数参数格式
 @return 返回写入的长度
 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 10, 0))
 static int advkill_conf_read( char *page, char **start, off_t off, int count, int *eof, void *data)
 {
 	int len;
@@ -119,7 +130,27 @@ static int advkill_conf_read( char *page, char **start, off_t off, int count, in
 
 	return len;
 }
+#else
+static int advkill_conf_seq_read(struct seq_file *seq, void *v)
+{
+	return seq_printf(seq, "%s\n", advkillconfdata);
+}
+static int advkill_conf_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, advkill_conf_seq_read, NULL);
+}
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION (3, 10, 0))
+static const struct file_operations advkill_fops = {
+	.owner = THIS_MODULE,
+	.open		= advkill_conf_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write 		= advkill_conf_write,
+	.release	= single_release,
+};
+#endif
 /**
 创建需要用到的proc文件
 
@@ -142,6 +173,7 @@ int create_proc_file(void)
 	}
 	else
 	{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 10, 0))
 		proc_advkill_conf = create_proc_entry(ADV_KILL_PROC_FILE, 0644, proc_dir);
 		if (proc_advkill_conf == NULL)
 		{
@@ -151,6 +183,15 @@ int create_proc_file(void)
 		}
 		proc_advkill_conf->read_proc = advkill_conf_read;
 		proc_advkill_conf->write_proc = advkill_conf_write;
+#else
+		proc_advkill_conf = proc_create(ADV_KILL_PROC_FILE, 0644, proc_dir, &advkill_fops);
+		if (proc_advkill_conf == NULL)
+		{
+			printk(KERN_ERR "Couldn't create proc entry[/proc/%s/%s]\n", ADV_KILL_PROC_DIRECTORY, ADV_KILL_PROC_FILE);
+			ret = -ENOMEM;
+			goto exit_fail;
+		}
+#endif
 	}
 
 	return ret;
diff --git a/advproc.h b/advproc.h
index b7eb47c..f922e7a 100644
--- a/advproc.h
+++ b/advproc.h
@@ -23,6 +23,10 @@
 #define _ADV_PROC_H_
 
 #include <linux/kernel.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION (3, 10, 0))
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#endif
 #include <linux/proc_fs.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>
diff --git a/pkgoper.c b/pkgoper.c
index 3728f89..72f7e86 100644
--- a/pkgoper.c
+++ b/pkgoper.c
@@ -100,6 +100,7 @@ struct sk_buff *pkg_skbuff_generate(struct sk_buff *skb, struct client_nicname *
 	struct tcphdr *tcph = NULL,*new_tcph = NULL;
 	struct ethhdr *ethdr = NULL;
 	char *newpdata = NULL;
+	unsigned char * mac_header_addr = NULL;
 	int i = 0;
 
 	if(!skb || !names)
@@ -124,10 +125,10 @@ struct sk_buff *pkg_skbuff_generate(struct sk_buff *skb, struct client_nicname *
 
 	for (i=0; names[i].index != -1; i++)
 	{
-#ifndef _BO_TONG_
-		dev = dev_get_by_name(&init_net, names[i].name);
-#else
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (2, 6, 24))//不确定版本号是否应该更早
 		dev = dev_get_by_name(names[i].name);
+#else
+		dev = dev_get_by_name(&init_net, names[i].name);
 #endif
 		if (dev != NULL)
 			break;
@@ -143,7 +144,7 @@ struct sk_buff *pkg_skbuff_generate(struct sk_buff *skb, struct client_nicname *
 	{
 		goto out;    
 	}    
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION (3, 11, 0))
 	new_skb->mac_header = new_skb->data;
 	skb_reserve(new_skb,14);
 	new_skb->transport_header = new_skb->data;
@@ -154,10 +155,27 @@ struct sk_buff *pkg_skbuff_generate(struct sk_buff *skb, struct client_nicname *
 	memcpy(&new_skb->mac_header[6], ethdr->h_dest, 6);
 	new_skb->mac_header[12] = 0x08;
 	new_skb->mac_header[13] = 0x00;
+#else
+	skb_reset_mac_header(new_skb);
+	skb_reserve(new_skb,14);
+	skb_reset_transport_header(new_skb);
+	skb_reset_network_header(new_skb);
+
+	mac_header_addr=skb_mac_header(new_skb);
+	if(mac_header_addr==NULL)
+	{
+		printk("Can't get header address!\n");
+		goto out;
+	}
+	//get_route_mac(iph->saddr, iph->daddr);
+	memcpy(mac_header_addr, ethdr->h_source, 6);
+	memcpy(mac_header_addr+6, ethdr->h_dest, 6);
+	mac_header_addr[12] = 0x08;
+	mac_header_addr[13] = 0x00;
+#endif
 	skb_put(new_skb, iph->ihl*4 + tcph->doff*4);
 	new_skb->mac_len = 14;
-
-	new_skb->dev = dev;  
+	new_skb->dev = dev;
 	new_skb->pkt_type = PACKET_OTHERHOST;
 	new_skb->protocol = __constant_htons(ETH_P_IP);
 	new_skb->ip_summed = CHECKSUM_NONE;
@@ -178,7 +196,7 @@ struct sk_buff *pkg_skbuff_generate(struct sk_buff *skb, struct client_nicname *
 	new_iph->saddr = iph->daddr;
 	new_iph->daddr = iph->saddr;
 	new_iph->tot_len = htons(tcpdatalen + iph->ihl*4 + tcph->doff*4);
-	new_iph->check = 0;   
+	new_iph->check = 0;
 	/*
 	 *TCP set
 	 */
@@ -206,7 +224,6 @@ struct sk_buff *pkg_skbuff_generate(struct sk_buff *skb, struct client_nicname *
 		}
 	}
 	refresh_skb_checksum(new_skb);
-
 	return new_skb;
 out:
 	if (NULL != skb)
@@ -232,22 +249,24 @@ int pkg_skbuff_dev_xmit(struct sk_buff *skb, char *tcpdata, int tcpdatalen)
 	int ret = 0;
 
 	new_skb_lan = pkg_skbuff_generate(skb, lan_name, sizeof(lan_name)/sizeof(struct client_nicname), tcpdata, tcpdatalen);
-
 	new_skb_lan->data -= 14;
 	new_skb_lan->len  += 14;
-	if((ret = dev_queue_xmit(new_skb_lan)) != 0)
+	ret = dev_queue_xmit(new_skb_lan);
+	if(ret != 0)
 	{
 #ifdef ADVKILL_PRINT_DEBUG_INFO
 		printk(KERN_ALERT "dev queue xmit failed %d\n",ret);
 #endif
 		return ADV_KILL_FAIL;
 	}
+	#if 0
 	/* Wireless */
 	new_skb_wlan = pkg_skbuff_generate(skb, wlan_name, sizeof(wlan_name)/sizeof(struct client_nicname), tcpdata, tcpdatalen);
 	new_skb_wlan->data -= 14;
 	new_skb_wlan->len  += 14;
 	dev_queue_xmit(new_skb_wlan);
 
+	#endif
 	return ADV_KILL_OK;
 }
 
diff --git a/pkgoper.h b/pkgoper.h
index 158a02d..0bcc6c9 100644
--- a/pkgoper.h
+++ b/pkgoper.h
@@ -43,8 +43,8 @@
 #define HTTP_FIND_LOCAL_STR_LEN								51
 
 /* lan interface */
-#define ETH_CLIENT_LAN0									"eth1"
-#define ETH_CLIENT_LAN1									"eth1"
+#define ETH_CLIENT_LAN0									"br-lan"
+#define ETH_CLIENT_LAN1									"br-lan"
 
 /* wlan interface */
 #define ETH_CLIENT_WLAN0								"vlan0"
